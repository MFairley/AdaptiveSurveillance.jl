        - using Random, Distributions
        - using StatsBase, StatsFuns
        - using FastClosures
        - using Optim, NLSolversBase
        - import Convex, Mosek, MosekTools
        - using Plots
        - 
        - ### Optim
        - function f_coeff(β, z, Γ::Int64, t::Int64)
        -     tΓ = max(0, t - Γ)
        -     return tΓ, β * tΓ  + z
        - end
        - 
        - function normalized_log_likelihood_scalar(β::Float64, z::Float64, Γ::Int64, t::Int64, W::Int64, n::Int64)
    45024     _, coeff = f_coeff(β, z, Γ, t)
    55248     p = logistic(coeff)
   161072     return logpdf(Binomial(n, p), W)
        - end
        - 
        - function normalized_log_likelihood(β::Float64, z::Float64, Γ::Int64, tp::Int64, Wp::Int64, t::Array{Int64}, W::Array{Int64}, n::Int64)
        -     f = 0.0
        -     for i = 1:length(W)
        -         f += normalized_log_likelihood_scalar(β, z, Γ, t[i], W[i], n)
        -     end
        -     f += normalized_log_likelihood_scalar(β, z, Γ, tp, Wp, n)
        -     return f
        - end
        - 
        - function log_likelihood_scalar(β, z, Γ::Int64, t::Int64, W::Int64, n::Int64)
205322208     _, coeff = f_coeff(β, z, Γ, t)
398684736     return W * coeff - n * log1pexp(coeff)
        - end
        - 
        - function log_likelihood(x, Γ::Int64, tp::Int64, Wp::Int64, t::Array{Int64}, W::Array{Int64}, n::Int64)
  3583744     β, z = x[1], x[2]
        -     f = 0.0
 94881536     for i = 1:length(W)
498743696         f -= log_likelihood_scalar(β, z, Γ, t[i], W[i], n)
        -     end
  5730688     f -= log_likelihood_scalar(β, z, Γ, tp, Wp, n)
   479200     return f
        - end
        - 
        - function log_likelihood_grad_scalar!(g::Array{Float64}, β::Float64, z::Float64, Γ::Int64, t::Int64, W::Int64, n::Int64)
319704800     tΓ, coeff = f_coeff(β, z, Γ, t)
421434032     sigd1 = logistic(coeff)
386736144     g[1] -= W * tΓ - n * sigd1 * tΓ
385009392     g[2] -= W - n * sigd1
        - end
        - 
        - function log_likelihood_grad!(g::Array{Float64}, x::Array{Float64}, Γ::Int64, tp::Int64, Wp::Int64, t::Array{Int64}, W::Array{Int64}, n::Int64)
  2854832     β, z = x[1], x[2]
  1093216     g[1] = 0.0
   858672     g[2] = 0.0
 66901680     for i = 1:length(W)
611419104         log_likelihood_grad_scalar!(g, β, z, Γ, t[i], W[i], n)
        -     end
  7110768     log_likelihood_grad_scalar!(g, β, z, Γ, tp, Wp, n)
        - end
        - 
        - function log_likelihood_hess_scalar!(h::Array{Float64}, β::Float64, z::Float64, Γ::Int64, t::Int64, n::Int64)
 61058240     tΓ, coeff = f_coeff(β, z, Γ, t)
201798960     sigd2 = logistic(coeff) * (1 - logistic(coeff))
109392288     h[1, 1] -= -n * (sigd2 * tΓ^2)
 69255168     h[1, 2] -= -n * tΓ * sigd2
 69010512     h[2, 1] -= -n * tΓ * sigd2
 72885872     h[2, 2] -= -n * sigd2
        - end
        - 
        - function log_likelihood_hess!(h::Array{Float64}, x::Array{Float64}, Γ::Int64, tp::Int64, t::Array{Int64}, n::Int64)
   329408     β, z = x[1], x[2]
   125952     h[1, 1] = 0.0
   302592     h[1, 2] = 0.0
   262512     h[2, 1] = 0.0
   464384     h[2, 2] = 0.0
 21466480     for i = 1:length(t)
123172928         log_likelihood_hess_scalar!(h, β, z, Γ, t[i], n)
        -     end
  1118976     log_likelihood_hess_scalar!(h, β, z, Γ, tp, n)
        - end
        - 
        - function solve_logistic_Γ_subproblem_optim(Γ::Int64, tp::Int64, Wp::Int64, t::Array{Int64}, W::Array{Int64}, n::Int64,
        -     x0 = [0.01, logit(0.01)], lx = [0.0, -Inf], ux = [1.0, logit(0.5)])
  2694608     fun = @closure (x) -> log_likelihood(x, Γ, tp, Wp, t, W, n)
     6480     fun_grad! = @closure (g, x) -> log_likelihood_grad!(g, x, Γ, tp, Wp, t, W, n)
  1584272     fun_hess! = @closure (h, x) -> log_likelihood_hess!(h, x, Γ, tp, t, n)
        -     
  1275056     df = TwiceDifferentiable(fun, fun_grad!, fun_hess!, x0)
  3911728     dfc = TwiceDifferentiableConstraints(lx, ux)
        -     
   249952     res = optimize(df, dfc, x0, IPNewton())
   524208     obj::Float64 = -Optim.minimum(res)
   308096     β::Float64, z::Float64 = Optim.minimizer(res)
        - 
    10976     return obj, β, z
        - end
        - 
        - function solve_logistic_optim(tp::Int64, Wp::Int64, t::Array{Int64}, W::Array{Int64}, n::Int64)
        -     max_obj = -Inf64
        -     βs = 0.0
        -     zs = 0.0
        -     Γs = 0
    45072     for Γ = 0:maximum(t) #  # to do, fix type instability here with Threads.@threads
   124432         obj, β, z = solve_logistic_Γ_subproblem_optim(Γ, tp, Wp, t, W, n)
        -         # obj, β, z = solve_logistic_Γ_subproblem_convex(Γ, vcat(t, tp), vcat(W, Wp), n)
    11808         if obj >= max_obj
        -             max_obj = obj
    73632             βs, zs, Γs = β, z, Γ
        -         end
        -     end
     1648     return max_obj, βs, zs, Γs
        - end
        - 
        - function profile_log_likelihood(n1::Int64, n2::Int64, tp::Int64, t::Array{Int64}, W::Array{Int64}, n::Int64)
        0     @assert n1 <= n2
        0     @assert tp > maximum(t)
        0     @assert 0 <= n1 <= n
        0     @assert 0 <= n2 <= n
      128     @assert all(0 .<= W .<= n)
      128     @assert all(t .>= 0)
      896     lp = zeros(n2 - n1 + 1)
        0     Wp_range = n1:n2
       80     Threads.@threads for i = 1:length(Wp_range)
        -         _, β, z, Γ = solve_logistic_optim(tp, Wp_range[i], t, W, n)
        -         lp[i] = normalized_log_likelihood(β, z, Γ, tp, Wp_range[i], t, W, n)
        -     end
        0     return lp
        - end
        - 
        - function future_alarm_log_probability(n1, n2, tp, W, t, n)
        0     return logsumexp(profile_log_likelihood(n1, n2, tp, t, W, n))
        - end
        - 
        - function profile_likelihood(tp, t, W, n)
        -     return softmax(profile_log_likelihood(0, n, tp, t, W, n))
        - end
        - 
        - function plot_profile_likelihood(tp, t, W, n; path = "")
        -     pl = profile_likelihood(tp, t, W, n)
        -     bar(0:n, pl, xlabel = "Number of Positive Tests", ylabel = "Probability", 
        -         legend=false, title = "Profile Likelihood for time $(tp) at time $(Int(maximum(t)))")
        -     savefig(joinpath(path, "profile_likelihood_$(tp)_$(Int(maximum(t))).pdf"))
        -     return pl
        - end
        - 
        - # ### Convex.jl
        - function solve_logistic_Γ_subproblem_convex(Γ, t, W, n, ux = [1.0, logit(0.5)])
        -     tΓ = max.(0, t .- Γ)
        -     β = Convex.Variable(Convex.Positive())
        -     z = Convex.Variable()
        -     coeff = β * tΓ + z
        -     obj = Convex.dot(W, coeff) - n * Convex.logisticloss(coeff)
        -     problem = Convex.maximize(obj, β <= ux[1], z <= ux[2])
        -     Convex.solve!(problem, () -> Mosek.Optimizer(QUIET=true), verbose=false)
        -     return problem.optval, Convex.evaluate(β), Convex.evaluate(z)
        - end
